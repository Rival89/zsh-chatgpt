#!/usr/bin/env zsh

# Main CLI for zsh-chatgpt

set -euo pipefail

script_dir=${0:A:h}
source "$script_dir/../config/config.zsh"
source "$script_dir/../utils/ui.zsh"

usage() {
  cat <<'EOF'
Usage: chatgpt [options] [prompt]

Options:
  -m, --model <name>      Select model (default: $OPENAI_MODEL)
  --session <name>        Use existing session
  --new-session <name>    Create and switch to a new session
  --list                  List available sessions
  --clear                 Clear current session conversation
  --image                 Generate image instead of chat completion
  --file <path>           Include file contents as context
  --cmd <command>         Include command output as context
  --pipe                  Read additional context from STDIN
  -h, --help              Show this help

Run without a prompt to enter interactive chat mode.
EOF
}

# -------------------------------------------------------------

model=$OPENAI_MODEL
session=$CHATGPT_DEFAULT_SESSION
new_session=
clear=false
list=false
image=false
file=""
cmd=""
from_pipe=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -m|--model) model="$2"; shift;;
    --session) session="$2"; shift;;
    --new-session) new_session="$2"; shift;;
    --clear) clear=true;;
    --list) list=true;;
    --image) image=true;;
    --file) file="$2"; shift;;
    --cmd) cmd="$2"; shift;;
    --pipe) from_pipe=true;;
    -h|--help) usage; return 0;;
    --) shift; break;;
    *) break;;
  esac
  shift
done

prompt="$*"

ensure_dirs

# Manage sessions ------------------------------------------------

session_file="$CHATGPT_SESSION_DIR/${session}.json"

if [[ -n $new_session ]]; then
  session="$new_session"
  session_file="$CHATGPT_SESSION_DIR/${session}.json"
  print '[]' > "$session_file"
fi

if $list; then
  for f in "$CHATGPT_SESSION_DIR"/*.json(N); do
    print ${f:t:r}
  done
  return 0
fi

if $clear; then
  : > "$session_file"
  print "Session '$session' cleared."
  return 0
fi

[[ -f "$session_file" ]] || print '[]' > "$session_file"

# Helper to build context ---------------------------------------

build_prompt() {
  local msg="$1" extra=""
  extra+=$'## Shell\n'"$(get_shell_context)"$'\n\n'
  [[ -n $file ]] && extra+=$"## File: $file\n$(<"$file")\n\n"
  if [[ -n $cmd ]]; then
    extra+=$"## Command: $cmd\n$(eval "$cmd" 2>/dev/null)\n\n"
  fi
  if $from_pipe; then
    local piped
    piped=$(cat)
    extra+=$"## STDIN\n$piped\n\n"
  fi
  printf '%s\n%s' "$extra" "$msg"
}

# Chat completion ------------------------------------------------

chat_request() {
  local user_msg="$1" buffer="" line content
  append_message "user" "$user_msg" "$session_file"

  curl -sS -N \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -H "Content-Type: application/json" \
    -d @- "$OPENAI_API_URL" <<EOF | while IFS= read -r line; do
{
  "model": "$model",
  "stream": true,
  "messages": $(cat "$session_file")
}
EOF
    [[ "$line" == "data: [DONE]" ]] && break
    content=$(echo "$line" | sed 's/^data: //' | jq -r '.choices[0].delta.content // empty')
    [[ -n $content ]] || continue
    print -n -- "$content"
    buffer+="$content"
  done
  echo
  append_message "assistant" "$buffer" "$session_file"
  log_turn "$session" "$user_msg" "$buffer"
}

# Image generation -----------------------------------------------

image_request() {
  local prompt="$1"
  curl -sS \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -H "Content-Type: application/json" \
    -d @- "$OPENAI_IMAGE_URL" <<EOF | jq -r '.data[0].url'
{
  "model": "$OPENAI_IMAGE_MODEL",
  "prompt": "$prompt"
}
EOF
}

# Handle single message ------------------------------------------

handle_message() {
  local input="$1"
  local built
  built=$(build_prompt "$input")
  if $image; then
    local url
    url=$(image_request "$built")
    print -- "$url"
  else
    chat_request "$built"
  fi
}

# Interactive loop ------------------------------------------------

interactive_loop() {
  local msg
  while true; do
    if command -v gum >/dev/null; then
      msg=$(gum input --prompt="You: ")
    else
      printf "%F{cyan}You:%f "
      read -r msg
    fi
    [[ -z $msg ]] && continue
    [[ $msg == exit || $msg == quit ]] && break
    handle_message "$msg"
  done
}

# Entry -----------------------------------------------------------

if [[ -n $prompt || $from_pipe || -n $file || -n $cmd ]]; then
  handle_message "$prompt"
else
  interactive_loop
fi

