#!/usr/bin/env zsh

chatgpt() {
  emulate -L zsh
  setopt extended_glob
  local user_input session_file tmpfile shell_context
  session_file="${CHAT_SESSION_FILE:-$HOME/.chatgpt_session.json}"
  tmpfile="$(mktemp)"

  # Ensure session file exists
  [[ ! -f "$session_file" ]] && echo '[]' > "$session_file"

  # Function to get shell context
  get_shell_context() {
    history | tail -n ${CHAT_SHELL_HISTORY_LINES:-5} | sed 's/^/ - /'
  }

  while true; do
    print -n "%F{cyan}You:%f "
    read -r user_input
    [[ "$user_input" == "exit" || "$user_input" == "quit" ]] && break

    shell_context=$(get_shell_context)

    # Inject context into user input
    full_prompt="Context:\n$shell_context\n\nMessage:\n$user_input"

    # Append user prompt
    jq --arg content "$full_prompt" \
       '. += [{"role":"user","content":$content}]' \
       "$session_file" > "$tmpfile" && mv "$tmpfile" "$session_file"

    print -n "%F{green}ChatGPT:%f "
    curl -sS -N \
      -H "Authorization: Bearer $OPENAI_API_KEY" \
      -H "Content-Type: application/json" \
      -d @- "$OPENAI_API_URL" <<EOF | while read -r line; do
{
  "model": "$OPENAI_MODEL",
  "stream": true,
  "messages": $(cat "$session_file")
}
EOF
      [[ "$line" == "data: [DONE]" ]] && break
      local content=$(echo "$line" | sed 's/^data: //' | jq -r '.choices[0].delta.content // empty')
      print -n -- "$content"
    done
    echo

    # Extract last assistant message from session and persist
    last_reply=$(jq -r '.[-1].content' "$session_file")
    [[ -n "$last_reply" ]] && jq --arg content "$last_reply" \
      '. += [{"role":"assistant","content":$content}]' \
      "$session_file" > "$tmpfile" && mv "$tmpfile" "$session_file"
  done
}
